package org.pattern_learener.structural.composite;

/**
 * Суть паттерна - это структурный паттерн проектирования, который позволяет сгруппировать множество объектов в древовидную структуру,
 * а затем работать с ней так, как будто это единичный объект.<p>
 * Применимость:<p>
 * - когда вам нужно представить древовидную структуру объектов;<p>
 * - когда клиенты должны единообразно трактовать простые и составные объекты;<p>
 * Преимущества и недостатки:<p>
 * + упрощает архитектуру клиента при работе со сложным деревом компонентов;<p>
 * + облегчает добавление новых видов компонентов;<p>
 * - создаёт слишком общий дизайн классов<p>
 * Реализация:<p>
 * 1. Убедитесь, что вашу бизнес-логику можно представить как древовидную структуру.
 * Попытайтесь разбить её на простые компоненты и контейнеры. Помните, что контейнеры могут содержать как простые компоненты,
 * так и другие вложенные контейнеры.<p>
 * 2. Создайте общий интерфейс компонентов, который объединит операции контейнеров и простых компонентов дерева.
 * Интерфейс будет удачным, если вы сможете использовать его, чтобы взаимозаменять простые и составные компоненты без потери смысла.<p>
 * 3. Создайте класс компонентов-листьев, не имеющих дальнейших ответвлений.
 * Имейте в виду, что программа может содержать несколько таких классов.<p>
 * 4. Создайте класс компонентов-контейнеров и добавьте в него массив для хранения ссылок на вложенные компоненты.
 * Этот массив должен быть способен содержать как простые, так и составные компоненты, поэтому убедитесь,
 * что он объявлен с типом интерфейса компонентов.
 * Реализуйте в контейнере методы интерфейса компонентов, помня о том,
 * что контейнеры должны делегировать основную работу своим дочерним компонентам.<p>
 * 5. Добавьте операции добавления и удаления дочерних компонентов в класс контейнеров.
 * Имейте в виду, что методы добавления/удаления дочерних компонентов можно поместить и в интерфейс компонентов.
 * Да, это нарушит принцип разделения интерфейса, так как реализации методов будут пустыми в компонентах-листьях.
 * Но зато все компоненты дерева станут действительно одинаковыми для клиента.
 */
public class CompositePattern {

    public static void main(String[] args) {
        SimpleFigure first = new SimpleFigure(10, 10);
        SimpleFigure second = new SimpleFigure();

        ComposeFigure composeFigure = new ComposeFigure();
        composeFigure.addChild(first);
        composeFigure.addChild(second);

        first.draw();
        first.move(20, 20);

        second.draw();
        second.move(50, 50);

        // за счет того, что и простая фигура и сложная реализуют один интерфейс,
        // мы можем одинаково обращаться и к простым и к сложным фигурам.
        composeFigure.draw();
        composeFigure.move(100, 100);
    }

}
