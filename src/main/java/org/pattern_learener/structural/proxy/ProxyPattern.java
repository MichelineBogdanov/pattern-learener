package org.pattern_learener.structural.proxy;

/**
 * Суть паттерна - это структурный паттерн проектирования, который позволяет подставлять вместо реальных объектов специальные объекты-заменители.
 * Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.<p>
 * Применимость:<p>
 * - ленивая инициализация (виртуальный прокси). Когда у вас есть тяжёлый объект, грузящий данные из файловой системы или базы данных;<p>
 * - защита доступа (защищающий прокси). Когда в программе есть разные типы пользователей, и вам хочется защищать объект от неавторизованного доступа.
 * Например, если ваши объекты — это важная часть операционной системы, а пользователи — сторонние программы (хорошие или вредоносные);<p>
 * - локальный запуск сервиса (удалённый прокси). Когда настоящий сервисный объект находится на удалённом сервере;<p>
 * - логирование запросов (логирующий прокси). Когда требуется хранить историю обращений к сервисному объекту;<p>
 * - кеширование объектов («умная» ссылка). Когда нужно кешировать результаты запросов клиентов и управлять их жизненным циклом;<p>
 * Преимущества и недостатки:<p>
 * + позволяет контролировать сервисный объект незаметно для клиента;<p>
 * + может работать, даже если сервисный объект ещё не создан;<p>
 * + может контролировать жизненный цикл служебного объекта;<p>
 * - усложняет код программы из-за введения дополнительных классов;<p>
 * - увеличивает время отклика от сервиса;<p>
 * Реализация:<p>
 * 1. Определите интерфейс, который бы сделал заместитель и оригинальный объект взаимозаменяемыми.<p>
 * 2. Создайте класс заместителя. Он должен содержать ссылку на сервисный объект.
 * Чаще всего, сервисный объект создаётся самим заместителем. В редких случаях заместитель получает готовый сервисный объект от клиента через конструктор.<p>
 * 3. Реализуйте методы заместителя в зависимости от его предназначения.
 * В большинстве случаев, проделав какую-то полезную работу, методы заместителя должны передать запрос сервисному объекту.<p>
 * 4. Подумайте о введении фабрики, которая решала бы, какой из объектов создавать — заместитель или реальный сервисный объект.
 * Но, с другой стороны, эта логика может быть помещена в создающий метод самого заместителя.<p>
 * 5. Подумайте, не реализовать ли вам ленивую инициализацию сервисного объекта при первом обращении клиента к методам заместителя.
 */
public class ProxyPattern {

    public static void main(String[] args) {
        YouTubeDownloader naiveDownloader = new YouTubeDownloader(new ThirdPartyYouTubeClass());
        YouTubeDownloader smartDownloader = new YouTubeDownloader(new YouTubeCacheProxy());

        long naive = test(naiveDownloader);
        long smart = test(smartDownloader);
        System.out.print("Time saved by caching proxy: " + (naive - smart) + "ms");
    }

    private static long test(YouTubeDownloader downloader) {
        long startTime = System.currentTimeMillis();

        // User behavior in our app:
        downloader.renderPopularVideos();
        downloader.renderVideoPage("catzzzzzzzzz");
        downloader.renderPopularVideos();
        downloader.renderVideoPage("dancesvideoo");
        // Users might visit the same page quite often.
        downloader.renderVideoPage("catzzzzzzzzz");
        downloader.renderVideoPage("someothervid");

        long estimatedTime = System.currentTimeMillis() - startTime;
        System.out.print("Time elapsed: " + estimatedTime + "ms\n");
        return estimatedTime;
    }

}
