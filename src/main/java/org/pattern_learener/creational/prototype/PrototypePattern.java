package org.pattern_learener.creational.prototype;

/**
 * Суть паттерна - это порождающий паттерн проектирования, который позволяет копировать объекты, не вдаваясь в подробности их реализации.<p>
 * Применимость:<p>
 * - когда ваш код не должен зависеть от классов копируемых объектов;<p>
 * - когда вы имеете уйму подклассов, которые отличаются начальными значениями полей. Кто-то мог создать все эти классы,
 * чтобы иметь возможность легко порождать объекты с определённой конфигурацией;<p>
 * Преимущества и недостатки:<p>
 * + позволяет клонировать объекты, не привязываясь к их конкретным классам;<p>
 * + меньше повторяющегося кода инициализации объектов;<p>
 * + ускоряет создание объектов;<p>
 * + альтернатива созданию подклассов для конструирования сложных объектов;<p>
 * - сложно клонировать составные объекты, имеющие ссылки на другие объекты<p>
 * Реализация:<p>
 * 1. Создайте интерфейс прототипов с единственным методом clone.
 * Если у вас уже есть иерархия продуктов, метод клонирования можно объявить непосредственно в каждом из её классов.<p>
 * 2. Добавьте в классы будущих прототипов альтернативный конструктор, принимающий в качестве аргумента объект текущего класса.
 * Этот конструктор должен скопировать из поданного объекта значения всех полей, объявленных в рамках текущего класса,
 * а затем передать выполнение родительскому конструктору, чтобы тот позаботился о полях, объявленных в суперклассе.
 * Если ваш язык программирования не поддерживает перегрузку методов, то вам не удастся создать несколько версий конструктора.
 * В этом случае копирование значений можно проводить и в другом методе, специально созданном для этих целей.
 * Конструктор удобнее тем, что позволяет клонировать объект за один вызов.<p>
 * 3. Метод клонирования обычно состоит всего из одной строки: вызова оператора new с конструктором прототипа.
 * Все классы, поддерживающие клонирование, должны явно определить метод clone, чтобы использовать собственный класс с оператором new.
 * В обратном случае результатом клонирования станет объект родительского класса.<p>
 * 4. Опционально, создайте центральное хранилище прототипов. В нём удобно хранить вариации объектов, возможно,
 * даже одного класса, но по-разному настроенных.
 * Вы можете разместить это хранилище либо в новом фабричном классе, либо в фабричном методе базового класса прототипов.
 * Такой фабричный метод должен на основании входящих аргументов искать в хранилище прототипов подходящий экземпляр,
 * а затем вызывать его метод клонирования и возвращать полученный объект.
 * Наконец, нужно избавиться от прямых вызовов конструкторов объектов, заменив их вызовами фабричного метода хранилища прототипов.<p>
 * ПС. Вообще в jdk уже есть интерфейс, который реализует данный паттерн (Cloneable).
 */
public class PrototypePattern {

    public static void main(String[] args) {
        Project master = new Project(1, "Project", "psvm");
        System.out.println(master);

        Project masterClone = (Project) master.copy();
        System.out.println(masterClone);

        ProjectFactory projectFactory = new ProjectFactory(master);
        Project project = projectFactory.cloneProject();
        System.out.println(project);
    }

}
