package org.pattern_learener.creational.factory_method;

/**
 * Суть паттерна - получение единого интерфейса для создания объектов разных подклассов.<p>
 * Применимость:<p>
 * - когда заранее неизвестны типы и зависимости объектов, с которыми должен работать ваш код;<p>
 * - когда вы хотите дать возможность пользователям расширять части вашего фреймворка или библиотеки;<p>
 * - когда вы хотите экономить системные ресурсы, повторно используя уже созданные объекты, вместо порождения новых;<p>
 * Преимущества и недостатки:<p>
 * + избавляет класс от привязки к конкретным классам продуктов;<p>
 * + выделяет код производства продуктов в одно место, упрощая поддержку кода;<p>
 * + упрощает добавление новых продуктов в программу;<p>
 * + реализует принцип открытости/закрытости;<p>
 * - может привести к созданию больших параллельных иерархий классов, так как для каждого класса продукта надо создать свой подкласс создателя<p>
 * Реализация:<p>
 * 1. Приведите все создаваемые продукты к общему интерфейсу.<p>
 * 2. В классе, который производит продукты, создайте пустой фабричный метод.
 * В качестве возвращаемого типа укажите общий интерфейс продукта.<p>
 * 3. Затем пройдитесь по коду класса и найдите все участки, создающие продукты.
 * Поочерёдно замените эти участки вызовами фабричного метода, перенося в него код создания различных продуктов.
 * В фабричный метод, возможно, придётся добавить несколько параметров, контролирующих, какой из продуктов нужно создать.
 * На этом этапе фабричный метод, скорее всего, будет выглядеть удручающе.
 * В нём будет жить большой условный оператор, выбирающий класс создаваемого продукта. Но не волнуйтесь, мы вот-вот исправим это.<p>
 * 4. Для каждого типа продуктов заведите подкласс и переопределите в нём фабричный метод.
 * Переместите туда код создания соответствующего продукта из суперкласса.<p>
 * 5. Если создаваемых продуктов слишком много для существующих подклассов создателя,
 * вы можете подумать о введении параметров в фабричный метод, которые позволят возвращать различные продукты в пределах одного подкласса.
 * Например, у вас есть класс Почта с подклассами АвиаПочта и НаземнаяПочта,
 * а также классы продуктов Самолёт, Грузовик и Поезд. Авиа соответствует Самолётам, но для НаземнойПочты есть сразу два продукта.
 * Вы могли бы создать новый подкласс почты для поездов, но проблему можно решить и по-другому.
 * Клиентский код может передавать в фабричный метод Наземной Почты аргумент, контролирующий тип создаваемого продукта.<p>
 * 6. Если после всех перемещений фабричный метод стал пустым, можете сделать его абстрактным.
 * Если в нём что-то осталось — не беда, это будет его реализацией по умолчанию.
 */
public class FactoryMethodPattern {

    public static void main(String[] args) {
        FactoryMethodPattern example = new FactoryMethodPattern();

        Dialog macDialog = example.initDialog("mac");
        macDialog.render();

        Dialog windowsDialog = example.initDialog("win");
        windowsDialog.render();
    }

    private Dialog initDialog(String platformName) {
        if ("win".equals(platformName)) {
            return new WinDialog();
        } else if ("mac".equals(platformName)) {
            return new MacDialog();
        }
        return new MacDialog();
    }

}
