package org.pattern_learener.behavioral.visitor;

/**
 * Суть паттерна - это поведенческий паттерн проектирования, который позволяет добавлять в программу новые операции,
 * не изменяя классы объектов, над которыми эти операции могут выполняться.<p>
 * Применимость:<p>
 * - когда вам нужно выполнить какую-то операцию над всеми элементами сложной структуры объектов, например, деревом;<p>
 * - когда над объектами сложной структуры объектов надо выполнять некоторые не связанные между собой операции, но вы не хотите «засорять» классы такими операциями;<p>
 * - когда новое поведение имеет смысл только для некоторых классов из существующей иерархии;<p>
 * Преимущества и недостатки:<p>
 * + упрощает добавление операций, работающих со сложными структурами объектов;<p>
 * + объединяет родственные операции в одном классе;<p>
 * + посетитель может накапливать состояние при обходе структуры элементов;<p>
 * - паттерн не оправдан, если иерархия элементов часто меняется;<p>
 * - может привести к нарушению инкапсуляции элементов;<p>
 * Реализация:<p>
 * 1. Создайте интерфейс посетителя и объявите в нём методы «посещения» для каждого класса элемента, который существует в программе.<p>
 * 2. Опишите интерфейс элементов. Если вы работаете с уже существующими классами, то объявите абстрактный метод принятия посетителей в базовом классе иерархии элементов.<p>
 * 3. Реализуйте методы принятия во всех конкретных элементах. Они должны переадресовывать вызовы тому методу посетителя,
 * в котором тип параметра совпадает с текущим классом элемента.<p>
 * 4. Иерархия элементов должна знать только о базовом интерфейсе посетителей. С другой стороны, посетители будут знать обо всех классах элементов.<p>
 * 5. Для каждого нового поведения создайте конкретный класс посетителя. Приспособьте это поведение для работы со всеми типами элементов,
 * реализовав все методы интерфейса посетителей.
 * Вы можете столкнуться с ситуацией, когда посетителю нужен будет доступ к приватным полям элементов.
 * В этом случае вы можете либо раскрыть доступ к этим полям, нарушив инкапсуляцию элементов,
 * либо сделать класс посетителя вложенным в класс элемента, если вам повезло писать на языке, который поддерживает вложенность классов.<p>
 * 6. Клиент будет создавать объекты посетителей, а затем передавать их элементам, используя метод принятия.
 */
public class VisitorPattern {

    public static void main(String[] args) {
        Dot dot = new Dot(1, 10, 55);
        Circle circle = new Circle(2, 23, 15, 10);
        Rectangle rectangle = new Rectangle(3, 10, 17, 20, 30);

        CompoundShape compoundShape = new CompoundShape(4);
        compoundShape.add(dot);
        compoundShape.add(circle);
        compoundShape.add(rectangle);

        CompoundShape c = new CompoundShape(5);
        c.add(dot);
        compoundShape.add(c);

        export(circle, compoundShape);
    }

    private static void export(Shape... shapes) {
        XMLExportVisitor exportVisitor = new XMLExportVisitor();
        System.out.println(exportVisitor.export(shapes));
    }

}
