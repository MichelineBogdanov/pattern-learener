package org.pattern_learener.behavioral.state;

/**
 * Суть паттерна - это поведенческий паттерн проектирования, который позволяет объектам менять поведение в зависимости от своего состояния.
 * Извне создаётся впечатление, что изменился класс объекта<p>
 * Применимость:<p>
 * - когда у вас есть объект, поведение которого кардинально меняется в зависимости от внутреннего состояния, причём типов состояний много, и их код часто меняется;<p>
 * - когда код класса содержит множество больших, похожих друг на друга, условных операторов, которые выбирают поведения в зависимости от текущих значений полей класса;<p>
 * - когда вы сознательно используете табличную машину состояний, построенную на условных операторах, но вынуждены мириться с дублированием кода для похожих состояний и переходов;<p>
 * Преимущества и недостатки:<p>
 * + избавляет от множества больших условных операторов машины состояний;<p>
 * + концентрирует в одном месте код, связанный с определённым состоянием;<p>
 * + упрощает код контекста;<p>
 * - может неоправданно усложнить код, если состояний мало и они редко меняются;<p>
 * Реализация:<p>
 * 1. Определитесь с классом, который будет играть роль контекста. Это может быть как существующий класс, в котором уже есть зависимость от состояния,
 * так и новый класс, если код состояний размазан по нескольким классам.<p>
 * 2. Создайте общий интерфейс состояний. Он должен описывать методы, общие для всех состояний, обнаруженных в контексте.
 * Заметьте, что не всё поведение контекста нужно переносить в состояние, а только то, которое зависит от состояний.<p>
 * 3. Для каждого фактического состояния создайте класс, реализующий интерфейс состояния. Переместите код, связанный с
 * конкретными состояниями в нужные классы. В конце концов, все методы интерфейса состояния должны быть реализованы во всех классах состояний.
 * При переносе поведения из контекста вы можете столкнуться с тем, что это поведение зависит от приватных полей или методов
 * контекста, к которым нет доступа из объекта состояния. Существует парочка способов обойти эту проблему.
 * Самый простой — оставить поведение внутри контекста, вызывая его из объекта состояния. С другой стороны, вы можете сделать
 * классы состояний вложенными в класс контекста, и тогда они получат доступ ко всем приватным частям контекста.
 * Но последний способ доступен только в некоторых языках программирования (например, Java, C#).<p>
 * 4. Создайте в контексте поле для хранения объектов-состояний, а также публичный метод для изменения значения этого поля.<p>
 * 5. Старые методы контекста, в которых находился зависимый от состояния код, замените на вызовы соответствующих методов объекта-состояния.<p>
 * 6. В зависимости от бизнес-логики, разместите код, который переключает состояние контекста либо внутри контекста,
 * либо внутри классов конкретных состояний.
 */
public class StatePattern {

    public static void main(String[] args) {
        Player player = new Player();
        UI ui = new UI(player);
        ui.init();
    }

}
