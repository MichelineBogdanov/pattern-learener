package org.pattern_learener.behavioral.observer;

/**
 * Суть паттерна - это поведенческий паттерн проектирования, который создаёт механизм подписки,
 * позволяющий одним объектам следить и реагировать на события, происходящие в других объектах<p>
 * Применимость:<p>
 * - когда после изменения состояния одного объекта требуется что-то сделать в других, но вы не знаете наперёд, какие именно объекты должны отреагировать;<p>
 * - когда одни объекты должны наблюдать за другими, но только в определённых случаях;<p>
 * Преимущества и недостатки:<p>
 * + издатели не зависят от конкретных классов подписчиков и наоборот;<p>
 * + вы можете подписывать и отписывать получателей на лету;<p>
 * + реализует принцип открытости/закрытости;<p>
 * - подписчики оповещаются в случайном порядке;<p>
 * Реализация:<p>
 * 1. Разбейте вашу функциональность на две части: независимое ядро и опциональные зависимые части.
 * Независимое ядро станет издателем. Зависимые части станут подписчиками.<p>
 * 2. Создайте интерфейс подписчиков. Обычно в нём достаточно определить единственный метод оповещения.<p>
 * 3. Создайте интерфейс издателей и опишите в нём операции управления подпиской. Помните, что издатель должен работать только с общим интерфейсом подписчиков.<p>
 * 4. Вам нужно решить, куда поместить код ведения подписки, ведь он обычно бывает одинаков для всех типов издателей.
 * Самый очевидный способ — вынести этот код в промежуточный абстрактный класс, от которого будут наследоваться все издатели.
 * Но если вы интегрируете паттерн в существующие классы, то создать новый базовый класс может быть затруднительно.
 * В этом случае вы можете поместить логику подписки во вспомогательный объект и делегировать ему работу из издателей.<p>
 * 5. Создайте классы конкретных издателей. Реализуйте их так, чтобы после каждого изменения состояния они отправляли оповещения всем своим подписчикам.<p>
 * 6. Реализуйте метод оповещения в конкретных подписчиках. Не забудьте предусмотреть параметры, через которые издатель
 * мог бы отправлять какие-то данные, связанные с происшедшим событием.
 * Возможен и другой вариант, когда подписчик, получив оповещение, сам возьмёт из объекта издателя нужные данные.
 * Но в этом случае вы будете вынуждены привязать класс подписчика к конкретному классу издателя.<p>
 * 7. Клиент должен создавать необходимое количество объектов подписчиков и подписывать их у издателей.
 */
public class ObserverPattern {

    public static void main(String[] args) {
        Editor editor = new Editor();
        editor.events.subscribe("open", new LogOpenListener("/path/to/log/file.txt"));
        editor.events.subscribe("save", new EmailNotificationListener("admin@example.com"));
        try {
            editor.openFile("test.txt");
            editor.saveFile();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
