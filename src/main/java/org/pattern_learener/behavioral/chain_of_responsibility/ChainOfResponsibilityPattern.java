package org.pattern_learener.behavioral.chain_of_responsibility;

import java.util.Scanner;

/**
 * Суть паттерна - это поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков.
 * Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.<p>
 * Применимость:<p>
 * - когда программа должна обрабатывать разнообразные запросы несколькими способами, но заранее неизвестно, какие конкретно запросы будут приходить и какие обработчики для них понадобятся;<p>
 * - когда важно, чтобы обработчики выполнялись один за другим в строгом порядке;<p>
 * - когда набор объектов, способных обработать запрос, должен задаваться динамически;<p>
 * Преимущества и недостатки:<p>
 * + уменьшает зависимость между клиентом и обработчиками.;<p>
 * + реализует принцип единственной обязанности;<p>
 * + реализует принцип открытости/закрытости;<p>
 * - запрос может остаться никем не обработанным;<p>
 * Реализация:<p>
 * 1. Создайте интерфейс обработчика и опишите в нём основной метод обработки.
 * Продумайте, в каком виде клиент должен передавать данные запроса в обработчик.
 * Самый гибкий способ — превратить данные запроса в объект и передавать его целиком через параметры метода обработчика.<p>
 * 2. Имеет смысл создать абстрактный базовый класс обработчиков, чтобы не дублировать реализацию метода получения следующего обработчика во всех конкретных обработчиках.
 * Добавьте в базовый обработчик поле для хранения ссылки на следующий объект цепочки.
 * Устанавливайте начальное значение этого поля через конструктор. Это сделает объекты обработчиков неизменяемыми.
 * Но если программа предполагает динамическую перестройку цепочек, можете добавить и сеттер для поля.
 * Реализуйте базовый метод обработки так, чтобы он перенаправлял запрос следующему объекту, проверив его наличие.
 * Это позволит полностью скрыть поле-ссылку от подклассов, дав им возможность передавать запросы дальше по цепи, обращаясь к родительской реализации метода.<p>
 * 3. Один за другим создайте классы конкретных обработчиков и реализуйте в них методы обработки запросов.
 * При получении запроса каждый обработчик должен решить:<p>
 * - Может ли он обработать запрос или нет?<p>
 * - Следует ли передать запрос следующему обработчику или нет?<p>
 * 4. Клиент может собирать цепочку обработчиков самостоятельно, опираясь на свою бизнес-логику, либо получать уже готовые цепочки извне.
 * В последнем случае цепочки собираются фабричными объектами, опираясь на конфигурацию приложения или параметры окружения.<p>
 * 5. Клиент может посылать запросы любому обработчику в цепи, а не только первому. Запрос будет передаваться по цепочке до тех пор,
 * пока какой-то обработчик не откажется передавать его дальше, либо когда будет достигнут конец цепи.<p>
 * 6. Клиент должен знать о динамической природе цепочки и быть готов к таким случаям:<p>
 * - Цепочка может состоять из единственного объекта.<p>
 * - Запросы могут не достигать конца цепи.<p>
 * - Запросы могут достигать конца, оставаясь необработанными.
 */
public class ChainOfResponsibilityPattern {

    public static void main(String[] args) {
        Server server = new Server();

        Checker emailChecker = new EmailChecker();
        Checker passChecker = new PassChecker();
        Checker roleChecker = new RoleChecker();

        emailChecker.setNext(passChecker);
        passChecker.setNext(roleChecker);

        server.linkCheckers(emailChecker, passChecker, roleChecker);

        Scanner scanner = new Scanner(System.in);
        Request request;
        do {
            System.out.println("Enter your email: ");
            String email = scanner.nextLine();
            System.out.println("Enter your password: ");
            String password = scanner.nextLine();
            request = new Request(email, password);
        } while (server.answerRequest(request));

    }

}
